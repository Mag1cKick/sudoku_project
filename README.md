# sudoku_project
розподіл:
1)Багатир-Захарченко Вероніка судоку і бек
2)Діжак Назар лабіринт і фронт
3)Кравчук Андрій розфарбовку і фронт
4)Слаблюк Назар кросворд і бек

Судоку

Лабіринт

Граф

Кросворд
Всі алгоритми працюють через бектрекінг і кросворд не вийняток. Для початку ми робимо матрицю в якій будемо проводити наші пошуки місць для підстановки слів. Для того щоб працювала функція нам потрібно прийняти саму матрицю від користувача, за допомогою фласку та хтмл. Також нам потрібно отримати набір слів для розстановки, адже наша ціль не розвʼязати кросворд, а розставити у ньому слова так, щоб його потім можна було поставити на вітрини магазинів з запитаннями для вирішення. Тож ми беремо слова і нашу матрицю, матрицю попередньо потрібно ще перетворити в матрицю, адже воно приймає стрічку з ентерами, перероблюємо її в ліст за допомогою спліт і стріп. Потім ми передаємо їх у клас cross1, у якому ми маємо ініт з словами, бордою та шляхами, якими можна розвʼязати кросворд. Тож далі перейдемо до функцій, адже вони найважливіші.

Функція hor_ch(x, y, grid, word) приймає позиції, у які можна вставити слова за допомогою х, у а також ми передаємо дошку, на яку ми і будемо вставляти слово і ми потім записуємо його в дошку, якщо у нас не можливо це зробити то тоді 1 символ ми замінюємо на 1 і тоді просто повертаємо дошку. Так ми записуємо горизонтально наше слово, надіючись що воно не перетнеться з іншими словами і пройде заповнення. Також ми передаємо слово, яке і будемо записувати.

Функція ver_ch(x, y, grid, word) приймає позиції, у які можна вставити слова за допомогою х, у а також ми передаємо дошку, на яку ми і будемо вставляти слово і ми потім записуємо його в дошку, якщо у нас не можливо це зробити то тоді 1 символ ми замінюємо на 1 і тоді просто повертаємо дошку. Так ми записуємо вертикально наше слово, надіючись що воно не перетнеться з іншими словами і пройде заповнення. Також ми передаємо слово, яке і будемо записувати.

Функція placements(self, grid, index, v, h) приймає також дошку, це необхідно бо вона працює рекурсивно і потім буде потрібно закидати нову дошку і нову, тому ми не можемо просто використовувати селф грід, також ми передаємо індекс для зміни слів які ми беремо як на початку так і під кінець нашого алгоритму, передаємо вертикальну довжину і горизонтальну щоб ми могли зробити поле будь-якого розміру, прямокутного а то буде все дуже погано. Тож далі ми маємо знайти ту довжину, на яку ми можемо розраховувати при підстановці слова і далі ми намагаємося підставити його вертикально у всі можливі вертикальні позиції також використовуючи бектрекінг, адже якщо ми знаходимо можливу підстановку для слова, то тоді у нас спрацьовує алгоритм, адже ми беремо нове слово і намагаємося його всунути горизонтально потім ще повертаємось і беремо горизонтально інше, коли не можна то вертикально всі можливі варіанти, потім знову для інших підстановок і так далі за допомогою алгоритму бектрекінг. Потім, коли у нас завершаться слова, які ми можемо підставити ми будемо додавати цей варіант до селф вейс і потім вже виводити на сайті у новому вікні всі варіанти, попередньо називаючи їх за допомогою формул, прописаних у аштімлі.

Висновок
Наші коди розвʼязують все за допомогою алгоритму бектрекінгу, який точно знайде ровʼязок для лабіринту, судоку і інших головоломок якщо він існує, так, він не є найефективнішим і це ми можемо бачити на прикладі лабіринту якщо залишити дошку повністю пустою і лише десь поставити старт і кінець то тоді видно, що алгоритм і де дуже довго і використовує набагато більше клітинок ніж потрібно для розвʼязку, але таке було завдання тож алгоритм є робочим і корисним для простого врішення будь - яких задач, але при цьому це не є ефективний алгоритм для цього, тож якщо у вас великий проєкт, то краще витратити на 10 хв більше часу і знайти в гуглі нормальний алгоритм для розвʼязку задат, або у вас можуть виникати проблеми з памʼяттю та часом виконання, що не є добре. Тепер ми вміємо робити бектрекінг на високому рівні і зможемо на його основі писати кращі алгоритми розвʼязку задач.
